{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, queryAll, dataAttr, getEventKey, getEventPoint } from '@zag-js/dom-query';\nimport { prev, next, ensure, isEqual, setRafTimeout, ensureProps, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `splitter:${ctx.id}`;\nvar getResizeTriggerId = (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`;\nvar getPanelId = (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`;\nvar getGlobalCursorId = ctx => `splitter:${ctx.id}:global-cursor`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));\nvar getCursor = (state, x) => {\n  let cursor = x ? \"col-resize\" : \"row-resize\";\n  if (state.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n  if (state.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n  return cursor;\n};\nvar getResizeTriggerEls = ctx => {\n  return queryAll(getRootEl(ctx), `[role=separator][data-ownedby='${CSS.escape(getRootId(ctx))}']`);\n};\nvar setupGlobalCursor = (ctx, state, x, nonce) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  const textContent = `* { cursor: ${getCursor(state, x)} !important; }`;\n  if (styleEl) {\n    styleEl.textContent = textContent;\n  } else {\n    const style = ctx.getDoc().createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    style.id = getGlobalCursorId(ctx);\n    style.textContent = textContent;\n    ctx.getDoc().head.appendChild(style);\n  }\n};\nvar removeGlobalCursor = ctx => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  styleEl?.remove();\n};\nfunction calculateAriaValues({\n  size,\n  panels,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  ensure(firstIndex, () => \"No pivot index found\");\n  panels.forEach((panel, index) => {\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = panel;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = size[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getAriaValue(size, panels, handleId) {\n  const [beforeId, afterId] = handleId.split(\":\");\n  const beforeIndex = panels.findIndex(panel => panel.id === beforeId);\n  const afterIndex = panels.findIndex(panel => panel.id === afterId);\n  const {\n    valueMax,\n    valueMin,\n    valueNow\n  } = calculateAriaValues({\n    size,\n    panels,\n    pivotIndices: [beforeIndex, afterIndex]\n  });\n  return {\n    beforeId,\n    afterId,\n    valueMax: Math.round(valueMax),\n    valueMin: Math.round(valueMin),\n    valueNow: valueNow != null ? Math.round(valueNow) : void 0\n  };\n}\n\n// src/utils/fuzzy.ts\nvar PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits = PRECISION) {\n  if (actual == null || expected == null) return false;\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzySizeEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getPanelById(panels, id) {\n  const panel = panels.find(panel2 => panel2.id === id);\n  ensure(panel, () => `Panel data not found for id \"${id}\"`);\n  return panel;\n}\nfunction findPanelDataIndex(panels, panel) {\n  return panels.findIndex(prevPanel => prevPanel === panel || prevPanel.id === panel.id);\n}\nfunction findPanelIndex(panels, id) {\n  return panels.findIndex(panel => panel.id === id);\n}\nfunction panelDataHelper(panels, panel, sizes) {\n  const index = findPanelIndex(panels, panel.id);\n  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];\n  const panelSize = sizes[index];\n  return {\n    ...panel,\n    panelSize,\n    pivotIndices\n  };\n}\nfunction sortPanels(panels) {\n  return panels.sort((panelA, panelB) => {\n    const orderA = panelA.order;\n    const orderB = panelB.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction getPanelLayout(panels) {\n  return panels.map(panel => panel.id).sort().join(\":\");\n}\nfunction serializePanels(panels) {\n  const keys = panels.map(panel => panel.id);\n  const sortedKeys = keys.sort();\n  const serialized = sortedKeys.map(key => {\n    const panel = panels.find(panel2 => panel2.id === key);\n    return JSON.stringify(panel);\n  });\n  return serialized.join(\",\");\n}\nfunction getPanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  sizes,\n  panels,\n  panelIndex,\n  precision = 3\n}) {\n  const size = sizes[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panels.length === 1) {\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : void 0\n  };\n}\nfunction getUnsafeDefaultSize({\n  panels,\n  size: sizes\n}) {\n  const finalSizes = Array(panels.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      finalSizes[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panels.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    finalSizes[index] = size;\n    remainingSize -= size;\n  }\n  return finalSizes;\n}\n\n// src/splitter.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    computed,\n    context,\n    scope\n  } = service;\n  const horizontal = computed(\"horizontal\");\n  const dragging = state.matches(\"dragging\");\n  const getPanelStyle = id => {\n    const panels = prop(\"panels\");\n    const panelIndex = panels.findIndex(panel => panel.id === id);\n    const defaultSize = context.initial(\"size\")[panelIndex];\n    const dragState = context.get(\"dragState\");\n    return getPanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      sizes: context.get(\"size\"),\n      panels,\n      panelIndex\n    });\n  };\n  return {\n    dragging,\n    getItems() {\n      return prop(\"panels\").flatMap((panel, index, arr) => {\n        const nextPanel = arr[index + 1];\n        if (panel && nextPanel) {\n          return [{\n            type: \"panel\",\n            id: panel.id\n          }, {\n            type: \"handle\",\n            id: `${panel.id}:${nextPanel.id}`\n          }];\n        }\n        return [{\n          type: \"panel\",\n          id: panel.id\n        }];\n      });\n    },\n    getSizes() {\n      return context.get(\"size\");\n    },\n    setSizes(size) {\n      send({\n        type: \"SIZE.SET\",\n        size\n      });\n    },\n    collapsePanel(id) {\n      send({\n        type: \"PANEL.COLLAPSE\",\n        id\n      });\n    },\n    expandPanel(id, minSize) {\n      send({\n        type: \"PANEL.EXPAND\",\n        id,\n        minSize\n      });\n    },\n    resizePanel(id, unsafePanelSize) {\n      send({\n        type: \"PANEL.RESIZE\",\n        id,\n        size: unsafePanelSize\n      });\n    },\n    getPanelSize(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return panelSize;\n    },\n    isPanelCollapsed(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);\n    },\n    isPanelExpanded(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    },\n    getLayout() {\n      return getPanelLayout(prop(\"panels\"));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      });\n    },\n    getPanelProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element({\n        ...parts.panel.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        \"data-id\": id,\n        \"data-index\": findPanelIndex(prop(\"panels\"), id),\n        id: getPanelId(scope, id),\n        \"data-ownedby\": getRootId(scope),\n        style: getPanelStyle(id)\n      });\n    },\n    getResizeTriggerProps(props2) {\n      const {\n        id,\n        disabled\n      } = props2;\n      const aria = getAriaValue(context.get(\"size\"), prop(\"panels\"), id);\n      const dragging2 = context.get(\"dragState\")?.resizeTriggerId === id;\n      const focused = dragging2 || context.get(\"keyboardState\")?.resizeTriggerId === id;\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getResizeTriggerId(scope, id),\n        role: \"separator\",\n        \"data-id\": id,\n        \"data-ownedby\": getRootId(scope),\n        tabIndex: disabled ? void 0 : 0,\n        \"aria-valuenow\": aria.valueNow,\n        \"aria-valuemin\": aria.valueMin,\n        \"aria-valuemax\": aria.valueMax,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-orientation\": prop(\"orientation\"),\n        \"aria-controls\": `${getPanelId(scope, aria.beforeId)} ${getPanelId(scope, aria.afterId)}`,\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: dragging2 && !focused ? \"none\" : void 0,\n          cursor: horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_DOWN\",\n            id,\n            point\n          });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_OVER\",\n            id\n          });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_LEAVE\",\n            id\n          });\n        },\n        onBlur() {\n          if (disabled) return;\n          send({\n            type: \"BLUR\"\n          });\n        },\n        onFocus() {\n          if (disabled) return;\n          send({\n            type: \"FOCUS\",\n            id\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          const keyboardResizeBy = prop(\"keyboardResizeBy\");\n          let delta = 0;\n          if (event.shiftKey) {\n            delta = 10;\n          } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n          } else {\n            delta = 1;\n          }\n          const keyMap = {\n            Enter() {\n              send({\n                type: \"ENTER\",\n                id\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : delta\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : delta\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? -delta : 0\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? delta : 0\n              });\n            },\n            Home() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: -100\n              });\n            },\n            End() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: 100\n              });\n            },\n            F6() {\n              send({\n                type: \"FOCUS.CYCLE\",\n                id,\n                shiftKey: event.shiftKey\n              });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nfunction resizePanel({\n  panels,\n  index,\n  size\n}) {\n  const panel = panels[index];\n  ensure(panel, () => `Panel data not found for index ${index}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panel;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// src/utils/resize-by-delta.ts\nfunction resizeByDelta(props2) {\n  let {\n    delta,\n    initialSize,\n    panels,\n    pivotIndices,\n    prevSize,\n    trigger\n  } = props2;\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialSize;\n  }\n  const nextSize = [...initialSize];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  ensure(firstPivotIndex, () => \"Invalid first pivot index\");\n  ensure(secondPivotIndex, () => \"Invalid second pivot index\");\n  let deltaApplied = 0;\n  {\n    if (trigger === \"keyboard\") {\n      {\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `Panel data not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {\n            const localDelta = minSize - prevSize2;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n      {\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `No panel data found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, minSize)) {\n            const localDelta = prevSize2 - collapsedSize;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n  {\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n    while (true) {\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panels,\n        index,\n        size: 100\n      });\n      const delta2 = maxSafeSize - prevSize2;\n      maxAvailableDelta += delta2;\n      index += increment;\n      if (index < 0 || index >= panels.length) {\n        break;\n      }\n    }\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n  {\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panels.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const unsafeSize = prevSize2 - deltaRemaining;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {\n        deltaApplied += prevSize2 - safeSize;\n        nextSize[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  if (fuzzySizeEqual(prevSize, nextSize)) {\n    return prevSize;\n  }\n  {\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize2 = initialSize[pivotIndex];\n    ensure(prevSize2, () => `Previous size not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize2 + deltaApplied;\n    const safeSize = resizePanel({\n      panels,\n      index: pivotIndex,\n      size: unsafeSize\n    });\n    nextSize[pivotIndex] = safeSize;\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex2;\n      while (index >= 0 && index < panels.length) {\n        const prevSize3 = nextSize[index];\n        ensure(prevSize3, () => `Previous size not found for panel index ${index}`);\n        const unsafeSize2 = prevSize3 + deltaRemaining;\n        const safeSize2 = resizePanel({\n          panels,\n          index,\n          size: unsafeSize2\n        });\n        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {\n          deltaRemaining -= safeSize2 - prevSize3;\n          nextSize[index] = safeSize2;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  const totalSize = nextSize.reduce((total, size) => size + total, 0);\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevSize;\n  }\n  return nextSize;\n}\nfunction validateSizes({\n  size: prevSize,\n  panels\n}) {\n  const nextSize = [...prevSize];\n  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);\n  if (nextSize.length !== panels.length) {\n    throw Error(`Invalid ${panels.length} panel size: ${nextSize.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {\n    for (let index = 0; index < panels.length; index++) {\n      const unsafeSize = nextSize[index];\n      ensure(unsafeSize, () => `No size data found for index ${index}`);\n      const safeSize = 100 / nextSizeTotalSize * unsafeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n  for (let index = 0; index < panels.length; index++) {\n    const unsafeSize = nextSize[index];\n    ensure(unsafeSize, () => `No size data found for index ${index}`);\n    const safeSize = resizePanel({\n      panels,\n      index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panels.length; index++) {\n      const prevSize2 = nextSize[index];\n      ensure(prevSize2, () => `No size data found for index ${index}`);\n      const unsafeSize = prevSize2 + remainingSize;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (prevSize2 !== safeSize) {\n        remainingSize -= safeSize - prevSize2;\n        nextSize[index] = safeSize;\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextSize;\n}\n\n// src/splitter.machine.ts\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    ensureProps(props2, [\"panels\"]);\n    return {\n      orientation: \"horizontal\",\n      defaultSize: [],\n      dir: \"ltr\",\n      ...props2,\n      panels: sortPanels(props2.panels)\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({\n    prop,\n    bindable,\n    getContext,\n    getRefs\n  }) {\n    return {\n      size: bindable(() => ({\n        value: prop(\"size\"),\n        defaultValue: prop(\"defaultSize\"),\n        isEqual(a, b) {\n          return b != null && fuzzySizeEqual(a, b);\n        },\n        onChange(value) {\n          const ctx = getContext();\n          const refs = getRefs();\n          const sizesBeforeCollapse = refs.get(\"panelSizeBeforeCollapse\");\n          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());\n          const resizeTriggerId = ctx.get(\"dragState\")?.resizeTriggerId ?? null;\n          const layout = getPanelLayout(prop(\"panels\"));\n          prop(\"onResize\")?.({\n            size: value,\n            layout,\n            resizeTriggerId,\n            expandToSizes\n          });\n        }\n      })),\n      dragState: bindable(() => ({\n        defaultValue: null\n      })),\n      keyboardState: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  watch({\n    track,\n    action,\n    prop\n  }) {\n    track([() => serializePanels(prop(\"panels\"))], () => {\n      action([\"syncSize\"]);\n    });\n  },\n  refs() {\n    return {\n      panelSizeBeforeCollapse: /* @__PURE__ */new Map(),\n      prevDelta: 0,\n      panelIdToLastNotifiedSizeMap: /* @__PURE__ */new Map()\n    };\n  },\n  computed: {\n    horizontal({\n      prop\n    }) {\n      return prop(\"orientation\") === \"horizontal\";\n    }\n  },\n  on: {\n    \"SIZE.SET\": {\n      actions: [\"setSize\"]\n    },\n    \"PANEL.COLLAPSE\": {\n      actions: [\"collapsePanel\"]\n    },\n    \"PANEL.EXPAND\": {\n      actions: [\"expandPanel\"]\n    },\n    \"PANEL.RESIZE\": {\n      actions: [\"resizePanel\"]\n    }\n  },\n  entry: [\"syncSize\"],\n  states: {\n    idle: {\n      entry: [\"clearDraggingState\", \"clearKeyboardState\"],\n      on: {\n        POINTER_OVER: {\n          target: \"hover:temp\",\n          actions: [\"setKeyboardState\"]\n        },\n        FOCUS: {\n          target: \"focused\",\n          actions: [\"setKeyboardState\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        }\n      }\n    },\n    \"hover:temp\": {\n      effects: [\"waitForHoverDelay\"],\n      on: {\n        HOVER_DELAY: {\n          target: \"hover\"\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    hover: {\n      tags: [\"focus\"],\n      on: {\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      on: {\n        BLUR: {\n          target: \"idle\"\n        },\n        ENTER: {\n          actions: [\"collapseOrExpandPanel\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        KEYBOARD_MOVE: {\n          actions: [\"invokeOnResizeStart\", \"setKeyboardValue\", \"invokeOnResizeEnd\"]\n        },\n        \"FOCUS.CYCLE\": {\n          actions: [\"focusNextResizeTrigger\"]\n        }\n      }\n    },\n    dragging: {\n      tags: [\"focus\"],\n      effects: [\"trackPointerMove\"],\n      entry: [\"invokeOnResizeStart\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"setPointerValue\", \"setGlobalCursor\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"invokeOnResizeEnd\", \"clearGlobalCursor\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      waitForHoverDelay: ({\n        send\n      }) => {\n        return setRafTimeout(() => {\n          send({\n            type: \"HOVER_DELAY\"\n          });\n        }, 250);\n      },\n      trackPointerMove: ({\n        scope,\n        send\n      }) => {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({\n              type: \"POINTER_MOVE\",\n              point: info.point\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"POINTER_UP\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      setSize(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const unsafeSize = event.size;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const safeSize = validateSizes({\n          size: unsafeSize,\n          panels\n        });\n        if (!isEqual(prevSize, safeSize)) {\n          setSize(params, safeSize);\n        }\n      },\n      syncSize({\n        context,\n        prop\n      }) {\n        const panels = prop(\"panels\");\n        let prevSize = context.get(\"size\");\n        let unsafeSize = null;\n        if (prevSize.length === 0) {\n          unsafeSize = getUnsafeDefaultSize({\n            panels,\n            size: context.initial(\"size\")\n          });\n        }\n        const nextSize = validateSizes({\n          size: unsafeSize ?? prevSize,\n          panels\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          context.set(\"size\", nextSize);\n        }\n      },\n      setDraggingState({\n        context,\n        event,\n        prop,\n        scope\n      }) {\n        const orientation = prop(\"orientation\");\n        const size = context.get(\"size\");\n        const resizeTriggerId = event.id;\n        const panelGroupEl = getRootEl(scope);\n        if (!panelGroupEl) return;\n        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);\n        ensure(handleElement, () => `Drag handle element not found for id \"${resizeTriggerId}\"`);\n        const initialCursorPosition = orientation === \"horizontal\" ? event.point.x : event.point.y;\n        context.set(\"dragState\", {\n          resizeTriggerId: event.id,\n          resizeTriggerRect: handleElement.getBoundingClientRect(),\n          initialCursorPosition,\n          initialSize: size\n        });\n      },\n      clearDraggingState({\n        context\n      }) {\n        context.set(\"dragState\", null);\n      },\n      setKeyboardState({\n        context,\n        event\n      }) {\n        context.set(\"keyboardState\", {\n          resizeTriggerId: event.id\n        });\n      },\n      clearKeyboardState({\n        context\n      }) {\n        context.set(\"keyboardState\", null);\n      },\n      collapsePanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            refs.get(\"panelSizeBeforeCollapse\").set(panel.id, panelSize);\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      expandPanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const panels = prop(\"panels\");\n        const prevSize = context.get(\"size\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize = 0,\n            minSize: minSizeFromProps = 0,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          const minSize = event.minSize ?? minSizeFromProps;\n          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            const prevPanelSize = refs.get(\"panelSizeBeforeCollapse\").get(panel.id);\n            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      resizePanel(params) {\n        const {\n          context,\n          prop,\n          event\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = getPanelById(panels, event.id);\n        const unsafePanelSize = event.size;\n        const {\n          panelSize,\n          pivotIndices\n        } = panelDataHelper(panels, panel, prevSize);\n        ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"imperative-api\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setPointerValue(params) {\n        const {\n          context,\n          event,\n          prop,\n          scope\n        } = params;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const {\n          resizeTriggerId,\n          initialSize,\n          initialCursorPosition\n        } = dragState;\n        const panels = prop(\"panels\");\n        const panelGroupElement = getRootEl(scope);\n        ensure(panelGroupElement, () => `Panel group element not found`);\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panels.findIndex(panel => panel.id === id));\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const cursorPosition = horizontal ? event.point.x : event.point.y;\n        const groupRect = panelGroupElement.getBoundingClientRect();\n        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;\n        const offsetPixels = cursorPosition - initialCursorPosition;\n        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta: offsetPercentage,\n          initialSize: initialSize ?? prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"mouse-or-touch\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setKeyboardValue(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const resizeTriggerId = event.id;\n        const delta = event.delta;\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panelDataArray.findIndex(panelData => panelData.id === id));\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels: panelDataArray,\n          pivotIndices,\n          prevSize,\n          trigger: \"keyboard\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      invokeOnResizeEnd({\n        context,\n        prop\n      }) {\n        queueMicrotask(() => {\n          const dragState = context.get(\"dragState\");\n          prop(\"onResizeEnd\")?.({\n            size: context.get(\"size\"),\n            resizeTriggerId: dragState?.resizeTriggerId ?? null\n          });\n        });\n      },\n      invokeOnResizeStart({\n        prop\n      }) {\n        queueMicrotask(() => {\n          prop(\"onResizeStart\")?.();\n        });\n      },\n      collapseOrExpandPanel(params) {\n        const {\n          context,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const sizes = context.get(\"size\");\n        const resizeTriggerId = context.get(\"keyboardState\")?.resizeTriggerId;\n        const [idBefore, idAfter] = resizeTriggerId?.split(\":\") ?? [];\n        const index = panelDataArray.findIndex(panelData2 => panelData2.id === idBefore);\n        if (index === -1) return;\n        const panelData = panelDataArray[index];\n        ensure(panelData, () => `No panel data found for index ${index}`);\n        const size = sizes[index];\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelData;\n        if (size != null && collapsible) {\n          const pivotIndices = [idBefore, idAfter].map(id => panelDataArray.findIndex(panelData2 => panelData2.id === id));\n          const nextSize = resizeByDelta({\n            delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n            initialSize: context.initial(\"size\"),\n            panels: panelDataArray,\n            pivotIndices,\n            prevSize: sizes,\n            trigger: \"keyboard\"\n          });\n          if (!isEqual(sizes, nextSize)) {\n            setSize(params, nextSize);\n          }\n        }\n      },\n      setGlobalCursor({\n        context,\n        scope,\n        prop\n      }) {\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const panels = prop(\"panels\");\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const [idBefore] = dragState.resizeTriggerId.split(\":\");\n        const indexBefore = panels.findIndex(panel2 => panel2.id === idBefore);\n        const panel = panels[indexBefore];\n        const size = context.get(\"size\");\n        const aria = getAriaValue(size, panels, dragState.resizeTriggerId);\n        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);\n        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);\n        const cursorState = {\n          isAtMin,\n          isAtMax\n        };\n        setupGlobalCursor(scope, cursorState, horizontal, prop(\"nonce\"));\n      },\n      clearGlobalCursor({\n        scope\n      }) {\n        removeGlobalCursor(scope);\n      },\n      focusNextResizeTrigger({\n        event,\n        scope\n      }) {\n        const resizeTriggers = getResizeTriggerEls(scope);\n        const index = resizeTriggers.findIndex(el => el.dataset.id === event.id);\n        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);\n        handleEl?.focus();\n      }\n    }\n  }\n});\nfunction setSize(params, sizes) {\n  const {\n    refs,\n    prop,\n    context\n  } = params;\n  const panelsArray = prop(\"panels\");\n  const onCollapse = prop(\"onCollapse\");\n  const onExpand = prop(\"onExpand\");\n  const panelIdToLastNotifiedSizeMap = refs.get(\"panelIdToLastNotifiedSizeMap\");\n  context.set(\"size\", sizes);\n  sizes.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    ensure(panelData, () => `Panel data not found for index ${index}`);\n    const {\n      collapsedSize = 0,\n      collapsible,\n      id: panelId\n    } = panelData;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap.set(panelId, size);\n      if (collapsible && (onCollapse || onExpand)) {\n        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size, collapsedSize)) {\n          onExpand?.({\n            panelId,\n            size\n          });\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size, collapsedSize)) {\n          onCollapse?.({\n            panelId,\n            size\n          });\n        }\n      }\n    }\n  });\n}\nvar props = createProps()([\"dir\", \"getRootNode\", \"id\", \"ids\", \"onResize\", \"onResizeStart\", \"onResizeEnd\", \"onCollapse\", \"onExpand\", \"orientation\", \"size\", \"defaultSize\", \"panels\", \"keyboardResizeBy\", \"nonce\"]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\nexport { anatomy, connect, getPanelLayout as layout, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };","map":{"version":3,"names":["createAnatomy","trackPointerMove","queryAll","dataAttr","getEventKey","getEventPoint","prev","next","ensure","isEqual","setRafTimeout","ensureProps","createSplitProps","createMachine","createProps","anatomy","parts","build","getRootId","ctx","ids","root","id","getResizeTriggerId","resizeTrigger","getPanelId","panel","getGlobalCursorId","getRootEl","getById","getResizeTriggerEl","getCursor","state","x","cursor","isAtMin","isAtMax","getResizeTriggerEls","CSS","escape","setupGlobalCursor","nonce","styleEl","textContent","style","getDoc","createElement","head","appendChild","removeGlobalCursor","remove","calculateAriaValues","size","panels","pivotIndices","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","forEach","index","maxSize","minSize","valueMax","Math","min","valueMin","max","valueNow","getAriaValue","handleId","beforeId","afterId","split","beforeIndex","findIndex","afterIndex","round","PRECISION","fuzzyCompareNumbers","actual","expected","fractionDigits","toFixed","fuzzyNumbersEqual","fuzzySizeEqual","length","actualSize","expectedSize","getPanelById","find","panel2","findPanelDataIndex","prevPanel","findPanelIndex","panelDataHelper","sizes","panelSize","sortPanels","sort","panelA","panelB","orderA","order","orderB","getPanelLayout","map","join","serializePanels","keys","sortedKeys","serialized","key","JSON","stringify","getPanelFlexBoxStyle","defaultSize","dragState","panelIndex","precision","flexGrow","toPrecision","flexBasis","flexShrink","overflow","pointerEvents","getUnsafeDefaultSize","finalSizes","Array","numPanelsWithSizes","remainingSize","numRemainingPanels","connect","service","normalize","send","prop","computed","context","scope","horizontal","dragging","matches","getPanelStyle","initial","get","getItems","flatMap","arr","nextPanel","type","getSizes","setSizes","collapsePanel","expandPanel","resizePanel","unsafePanelSize","getPanelSize","panelData","isPanelCollapsed","collapsedSize","collapsible","isPanelExpanded","getLayout","getRootProps","element","attrs","dir","display","flexDirection","height","width","getPanelProps","props2","getResizeTriggerProps","disabled","aria","dragging2","resizeTriggerId","focused","role","tabIndex","touchAction","userSelect","WebkitUserSelect","flex","onPointerDown","event","button","preventDefault","point","currentTarget","setPointerCapture","pointerId","stopPropagation","onPointerUp","hasPointerCapture","releasePointerCapture","onPointerOver","onPointerLeave","onBlur","onFocus","onKeyDown","defaultPrevented","keyboardResizeBy","delta","shiftKey","keyMap","Enter","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Home","End","F6","orientation","exec","halfwayPoint","parseFloat","resizeByDelta","initialSize","prevSize","trigger","nextSize","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize2","localDelta","abs","increment","maxAvailableDelta","maxSafeSize","delta2","minAbsDelta","pivotIndex","deltaRemaining","unsafeSize","safeSize","localeCompare","numeric","pivotIndex2","prevSize3","unsafeSize2","safeSize2","totalSize","reduce","total","validateSizes","nextSizeTotalSize","accumulated","current","Error","machine","props","initialState","bindable","getContext","getRefs","value","defaultValue","a","b","onChange","refs","sizesBeforeCollapse","expandToSizes","Object","fromEntries","entries","layout","keyboardState","watch","track","action","panelSizeBeforeCollapse","Map","prevDelta","panelIdToLastNotifiedSizeMap","on","actions","entry","states","idle","POINTER_OVER","target","FOCUS","POINTER_DOWN","effects","HOVER_DELAY","POINTER_LEAVE","hover","tags","BLUR","ENTER","KEYBOARD_MOVE","POINTER_MOVE","POINTER_UP","implementations","waitForHoverDelay","doc","onPointerMove","info","setSize","params","syncSize","set","setDraggingState","panelGroupEl","handleElement","initialCursorPosition","y","resizeTriggerRect","getBoundingClientRect","clearDraggingState","setKeyboardState","clearKeyboardState","isLastPanel","minSizeFromProps","prevPanelSize","baseSize","setPointerValue","panelGroupElement","cursorPosition","groupRect","groupSizeInPixels","offsetPixels","offsetPercentage","setKeyboardValue","panelDataArray","invokeOnResizeEnd","queueMicrotask","invokeOnResizeStart","collapseOrExpandPanel","idBefore","idAfter","panelData2","setGlobalCursor","indexBefore","cursorState","clearGlobalCursor","focusNextResizeTrigger","resizeTriggers","el","dataset","handleEl","focus","panelsArray","onCollapse","onExpand","panelId","lastNotifiedSize","splitProps","panelProps","splitPanelProps","resizeTriggerProps","splitResizeTriggerProps"],"sources":["C:/Users/Teren/Documents/GitHub/arbitrage-betting/node_modules/@zag-js/splitter/dist/index.mjs"],"sourcesContent":["import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, queryAll, dataAttr, getEventKey, getEventPoint } from '@zag-js/dom-query';\nimport { prev, next, ensure, isEqual, setRafTimeout, ensureProps, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\");\nvar parts = anatomy.build();\nvar getRootId = (ctx) => ctx.ids?.root ?? `splitter:${ctx.id}`;\nvar getResizeTriggerId = (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`;\nvar getPanelId = (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`;\nvar getGlobalCursorId = (ctx) => `splitter:${ctx.id}:global-cursor`;\nvar getRootEl = (ctx) => ctx.getById(getRootId(ctx));\nvar getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));\nvar getCursor = (state, x) => {\n  let cursor = x ? \"col-resize\" : \"row-resize\";\n  if (state.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n  if (state.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n  return cursor;\n};\nvar getResizeTriggerEls = (ctx) => {\n  return queryAll(getRootEl(ctx), `[role=separator][data-ownedby='${CSS.escape(getRootId(ctx))}']`);\n};\nvar setupGlobalCursor = (ctx, state, x, nonce) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  const textContent = `* { cursor: ${getCursor(state, x)} !important; }`;\n  if (styleEl) {\n    styleEl.textContent = textContent;\n  } else {\n    const style = ctx.getDoc().createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    style.id = getGlobalCursorId(ctx);\n    style.textContent = textContent;\n    ctx.getDoc().head.appendChild(style);\n  }\n};\nvar removeGlobalCursor = (ctx) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  styleEl?.remove();\n};\nfunction calculateAriaValues({\n  size,\n  panels,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  ensure(firstIndex, () => \"No pivot index found\");\n  panels.forEach((panel, index) => {\n    const { maxSize = 100, minSize = 0 } = panel;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = size[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getAriaValue(size, panels, handleId) {\n  const [beforeId, afterId] = handleId.split(\":\");\n  const beforeIndex = panels.findIndex((panel) => panel.id === beforeId);\n  const afterIndex = panels.findIndex((panel) => panel.id === afterId);\n  const { valueMax, valueMin, valueNow } = calculateAriaValues({\n    size,\n    panels,\n    pivotIndices: [beforeIndex, afterIndex]\n  });\n  return {\n    beforeId,\n    afterId,\n    valueMax: Math.round(valueMax),\n    valueMin: Math.round(valueMin),\n    valueNow: valueNow != null ? Math.round(valueNow) : void 0\n  };\n}\n\n// src/utils/fuzzy.ts\nvar PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits = PRECISION) {\n  if (actual == null || expected == null) return false;\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzySizeEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getPanelById(panels, id) {\n  const panel = panels.find((panel2) => panel2.id === id);\n  ensure(panel, () => `Panel data not found for id \"${id}\"`);\n  return panel;\n}\nfunction findPanelDataIndex(panels, panel) {\n  return panels.findIndex((prevPanel) => prevPanel === panel || prevPanel.id === panel.id);\n}\nfunction findPanelIndex(panels, id) {\n  return panels.findIndex((panel) => panel.id === id);\n}\nfunction panelDataHelper(panels, panel, sizes) {\n  const index = findPanelIndex(panels, panel.id);\n  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];\n  const panelSize = sizes[index];\n  return { ...panel, panelSize, pivotIndices };\n}\nfunction sortPanels(panels) {\n  return panels.sort((panelA, panelB) => {\n    const orderA = panelA.order;\n    const orderB = panelB.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction getPanelLayout(panels) {\n  return panels.map((panel) => panel.id).sort().join(\":\");\n}\nfunction serializePanels(panels) {\n  const keys = panels.map((panel) => panel.id);\n  const sortedKeys = keys.sort();\n  const serialized = sortedKeys.map((key) => {\n    const panel = panels.find((panel2) => panel2.id === key);\n    return JSON.stringify(panel);\n  });\n  return serialized.join(\",\");\n}\nfunction getPanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  sizes,\n  panels,\n  panelIndex,\n  precision = 3\n}) {\n  const size = sizes[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panels.length === 1) {\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : void 0\n  };\n}\nfunction getUnsafeDefaultSize({ panels, size: sizes }) {\n  const finalSizes = Array(panels.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      finalSizes[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panels.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    finalSizes[index] = size;\n    remainingSize -= size;\n  }\n  return finalSizes;\n}\n\n// src/splitter.connect.ts\nfunction connect(service, normalize) {\n  const { state, send, prop, computed, context, scope } = service;\n  const horizontal = computed(\"horizontal\");\n  const dragging = state.matches(\"dragging\");\n  const getPanelStyle = (id) => {\n    const panels = prop(\"panels\");\n    const panelIndex = panels.findIndex((panel) => panel.id === id);\n    const defaultSize = context.initial(\"size\")[panelIndex];\n    const dragState = context.get(\"dragState\");\n    return getPanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      sizes: context.get(\"size\"),\n      panels,\n      panelIndex\n    });\n  };\n  return {\n    dragging,\n    getItems() {\n      return prop(\"panels\").flatMap((panel, index, arr) => {\n        const nextPanel = arr[index + 1];\n        if (panel && nextPanel) {\n          return [\n            { type: \"panel\", id: panel.id },\n            { type: \"handle\", id: `${panel.id}:${nextPanel.id}` }\n          ];\n        }\n        return [{ type: \"panel\", id: panel.id }];\n      });\n    },\n    getSizes() {\n      return context.get(\"size\");\n    },\n    setSizes(size) {\n      send({ type: \"SIZE.SET\", size });\n    },\n    collapsePanel(id) {\n      send({ type: \"PANEL.COLLAPSE\", id });\n    },\n    expandPanel(id, minSize) {\n      send({ type: \"PANEL.EXPAND\", id, minSize });\n    },\n    resizePanel(id, unsafePanelSize) {\n      send({ type: \"PANEL.RESIZE\", id, size: unsafePanelSize });\n    },\n    getPanelSize(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return panelSize;\n    },\n    isPanelCollapsed(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);\n    },\n    isPanelExpanded(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    },\n    getLayout() {\n      return getPanelLayout(prop(\"panels\"));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      });\n    },\n    getPanelProps(props2) {\n      const { id } = props2;\n      return normalize.element({\n        ...parts.panel.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        \"data-id\": id,\n        \"data-index\": findPanelIndex(prop(\"panels\"), id),\n        id: getPanelId(scope, id),\n        \"data-ownedby\": getRootId(scope),\n        style: getPanelStyle(id)\n      });\n    },\n    getResizeTriggerProps(props2) {\n      const { id, disabled } = props2;\n      const aria = getAriaValue(context.get(\"size\"), prop(\"panels\"), id);\n      const dragging2 = context.get(\"dragState\")?.resizeTriggerId === id;\n      const focused = dragging2 || context.get(\"keyboardState\")?.resizeTriggerId === id;\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getResizeTriggerId(scope, id),\n        role: \"separator\",\n        \"data-id\": id,\n        \"data-ownedby\": getRootId(scope),\n        tabIndex: disabled ? void 0 : 0,\n        \"aria-valuenow\": aria.valueNow,\n        \"aria-valuemin\": aria.valueMin,\n        \"aria-valuemax\": aria.valueMax,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-orientation\": prop(\"orientation\"),\n        \"aria-controls\": `${getPanelId(scope, aria.beforeId)} ${getPanelId(scope, aria.afterId)}`,\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: dragging2 && !focused ? \"none\" : void 0,\n          cursor: horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          const point = getEventPoint(event);\n          send({ type: \"POINTER_DOWN\", id, point });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (disabled) return;\n          send({ type: \"POINTER_OVER\", id });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({ type: \"POINTER_LEAVE\", id });\n        },\n        onBlur() {\n          if (disabled) return;\n          send({ type: \"BLUR\" });\n        },\n        onFocus() {\n          if (disabled) return;\n          send({ type: \"FOCUS\", id });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          const keyboardResizeBy = prop(\"keyboardResizeBy\");\n          let delta = 0;\n          if (event.shiftKey) {\n            delta = 10;\n          } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n          } else {\n            delta = 1;\n          }\n          const keyMap = {\n            Enter() {\n              send({ type: \"ENTER\", id });\n            },\n            ArrowUp() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? 0 : delta });\n            },\n            ArrowDown() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? 0 : delta });\n            },\n            ArrowLeft() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? -delta : 0 });\n            },\n            ArrowRight() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: horizontal ? delta : 0 });\n            },\n            Home() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: -100 });\n            },\n            End() {\n              send({ type: \"KEYBOARD_MOVE\", id, delta: 100 });\n            },\n            F6() {\n              send({ type: \"FOCUS.CYCLE\", id, shiftKey: event.shiftKey });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nfunction resizePanel({ panels, index, size }) {\n  const panel = panels[index];\n  ensure(panel, () => `Panel data not found for index ${index}`);\n  let { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panel;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// src/utils/resize-by-delta.ts\nfunction resizeByDelta(props2) {\n  let { delta, initialSize, panels, pivotIndices, prevSize, trigger } = props2;\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialSize;\n  }\n  const nextSize = [...initialSize];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  ensure(firstPivotIndex, () => \"Invalid first pivot index\");\n  ensure(secondPivotIndex, () => \"Invalid second pivot index\");\n  let deltaApplied = 0;\n  {\n    if (trigger === \"keyboard\") {\n      {\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `Panel data not found for index ${index}`);\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {\n            const localDelta = minSize - prevSize2;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n      {\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `No panel data found for index ${index}`);\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, minSize)) {\n            const localDelta = prevSize2 - collapsedSize;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n  {\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n    while (true) {\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panels,\n        index,\n        size: 100\n      });\n      const delta2 = maxSafeSize - prevSize2;\n      maxAvailableDelta += delta2;\n      index += increment;\n      if (index < 0 || index >= panels.length) {\n        break;\n      }\n    }\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n  {\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panels.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const unsafeSize = prevSize2 - deltaRemaining;\n      const safeSize = resizePanel({ panels, index, size: unsafeSize });\n      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {\n        deltaApplied += prevSize2 - safeSize;\n        nextSize[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  if (fuzzySizeEqual(prevSize, nextSize)) {\n    return prevSize;\n  }\n  {\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize2 = initialSize[pivotIndex];\n    ensure(prevSize2, () => `Previous size not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize2 + deltaApplied;\n    const safeSize = resizePanel({ panels, index: pivotIndex, size: unsafeSize });\n    nextSize[pivotIndex] = safeSize;\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex2;\n      while (index >= 0 && index < panels.length) {\n        const prevSize3 = nextSize[index];\n        ensure(prevSize3, () => `Previous size not found for panel index ${index}`);\n        const unsafeSize2 = prevSize3 + deltaRemaining;\n        const safeSize2 = resizePanel({ panels, index, size: unsafeSize2 });\n        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {\n          deltaRemaining -= safeSize2 - prevSize3;\n          nextSize[index] = safeSize2;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  const totalSize = nextSize.reduce((total, size) => size + total, 0);\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevSize;\n  }\n  return nextSize;\n}\nfunction validateSizes({ size: prevSize, panels }) {\n  const nextSize = [...prevSize];\n  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);\n  if (nextSize.length !== panels.length) {\n    throw Error(`Invalid ${panels.length} panel size: ${nextSize.map((size) => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {\n    for (let index = 0; index < panels.length; index++) {\n      const unsafeSize = nextSize[index];\n      ensure(unsafeSize, () => `No size data found for index ${index}`);\n      const safeSize = 100 / nextSizeTotalSize * unsafeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n  for (let index = 0; index < panels.length; index++) {\n    const unsafeSize = nextSize[index];\n    ensure(unsafeSize, () => `No size data found for index ${index}`);\n    const safeSize = resizePanel({ panels, index, size: unsafeSize });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panels.length; index++) {\n      const prevSize2 = nextSize[index];\n      ensure(prevSize2, () => `No size data found for index ${index}`);\n      const unsafeSize = prevSize2 + remainingSize;\n      const safeSize = resizePanel({ panels, index, size: unsafeSize });\n      if (prevSize2 !== safeSize) {\n        remainingSize -= safeSize - prevSize2;\n        nextSize[index] = safeSize;\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextSize;\n}\n\n// src/splitter.machine.ts\nvar machine = createMachine({\n  props({ props: props2 }) {\n    ensureProps(props2, [\"panels\"]);\n    return {\n      orientation: \"horizontal\",\n      defaultSize: [],\n      dir: \"ltr\",\n      ...props2,\n      panels: sortPanels(props2.panels)\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({ prop, bindable, getContext, getRefs }) {\n    return {\n      size: bindable(() => ({\n        value: prop(\"size\"),\n        defaultValue: prop(\"defaultSize\"),\n        isEqual(a, b) {\n          return b != null && fuzzySizeEqual(a, b);\n        },\n        onChange(value) {\n          const ctx = getContext();\n          const refs = getRefs();\n          const sizesBeforeCollapse = refs.get(\"panelSizeBeforeCollapse\");\n          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());\n          const resizeTriggerId = ctx.get(\"dragState\")?.resizeTriggerId ?? null;\n          const layout = getPanelLayout(prop(\"panels\"));\n          prop(\"onResize\")?.({\n            size: value,\n            layout,\n            resizeTriggerId,\n            expandToSizes\n          });\n        }\n      })),\n      dragState: bindable(() => ({\n        defaultValue: null\n      })),\n      keyboardState: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  watch({ track, action, prop }) {\n    track([() => serializePanels(prop(\"panels\"))], () => {\n      action([\"syncSize\"]);\n    });\n  },\n  refs() {\n    return {\n      panelSizeBeforeCollapse: /* @__PURE__ */ new Map(),\n      prevDelta: 0,\n      panelIdToLastNotifiedSizeMap: /* @__PURE__ */ new Map()\n    };\n  },\n  computed: {\n    horizontal({ prop }) {\n      return prop(\"orientation\") === \"horizontal\";\n    }\n  },\n  on: {\n    \"SIZE.SET\": {\n      actions: [\"setSize\"]\n    },\n    \"PANEL.COLLAPSE\": {\n      actions: [\"collapsePanel\"]\n    },\n    \"PANEL.EXPAND\": {\n      actions: [\"expandPanel\"]\n    },\n    \"PANEL.RESIZE\": {\n      actions: [\"resizePanel\"]\n    }\n  },\n  entry: [\"syncSize\"],\n  states: {\n    idle: {\n      entry: [\"clearDraggingState\", \"clearKeyboardState\"],\n      on: {\n        POINTER_OVER: {\n          target: \"hover:temp\",\n          actions: [\"setKeyboardState\"]\n        },\n        FOCUS: {\n          target: \"focused\",\n          actions: [\"setKeyboardState\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        }\n      }\n    },\n    \"hover:temp\": {\n      effects: [\"waitForHoverDelay\"],\n      on: {\n        HOVER_DELAY: {\n          target: \"hover\"\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    hover: {\n      tags: [\"focus\"],\n      on: {\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      on: {\n        BLUR: {\n          target: \"idle\"\n        },\n        ENTER: {\n          actions: [\"collapseOrExpandPanel\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        KEYBOARD_MOVE: {\n          actions: [\"invokeOnResizeStart\", \"setKeyboardValue\", \"invokeOnResizeEnd\"]\n        },\n        \"FOCUS.CYCLE\": {\n          actions: [\"focusNextResizeTrigger\"]\n        }\n      }\n    },\n    dragging: {\n      tags: [\"focus\"],\n      effects: [\"trackPointerMove\"],\n      entry: [\"invokeOnResizeStart\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"setPointerValue\", \"setGlobalCursor\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"invokeOnResizeEnd\", \"clearGlobalCursor\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      waitForHoverDelay: ({ send }) => {\n        return setRafTimeout(() => {\n          send({ type: \"HOVER_DELAY\" });\n        }, 250);\n      },\n      trackPointerMove: ({ scope, send }) => {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({ type: \"POINTER_MOVE\", point: info.point });\n          },\n          onPointerUp() {\n            send({ type: \"POINTER_UP\" });\n          }\n        });\n      }\n    },\n    actions: {\n      setSize(params) {\n        const { context, event, prop } = params;\n        const unsafeSize = event.size;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const safeSize = validateSizes({\n          size: unsafeSize,\n          panels\n        });\n        if (!isEqual(prevSize, safeSize)) {\n          setSize(params, safeSize);\n        }\n      },\n      syncSize({ context, prop }) {\n        const panels = prop(\"panels\");\n        let prevSize = context.get(\"size\");\n        let unsafeSize = null;\n        if (prevSize.length === 0) {\n          unsafeSize = getUnsafeDefaultSize({\n            panels,\n            size: context.initial(\"size\")\n          });\n        }\n        const nextSize = validateSizes({\n          size: unsafeSize ?? prevSize,\n          panels\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          context.set(\"size\", nextSize);\n        }\n      },\n      setDraggingState({ context, event, prop, scope }) {\n        const orientation = prop(\"orientation\");\n        const size = context.get(\"size\");\n        const resizeTriggerId = event.id;\n        const panelGroupEl = getRootEl(scope);\n        if (!panelGroupEl) return;\n        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);\n        ensure(handleElement, () => `Drag handle element not found for id \"${resizeTriggerId}\"`);\n        const initialCursorPosition = orientation === \"horizontal\" ? event.point.x : event.point.y;\n        context.set(\"dragState\", {\n          resizeTriggerId: event.id,\n          resizeTriggerRect: handleElement.getBoundingClientRect(),\n          initialCursorPosition,\n          initialSize: size\n        });\n      },\n      clearDraggingState({ context }) {\n        context.set(\"dragState\", null);\n      },\n      setKeyboardState({ context, event }) {\n        context.set(\"keyboardState\", {\n          resizeTriggerId: event.id\n        });\n      },\n      clearKeyboardState({ context }) {\n        context.set(\"keyboardState\", null);\n      },\n      collapsePanel(params) {\n        const { context, prop, event, refs } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = panels.find((panel2) => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);\n          ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            refs.get(\"panelSizeBeforeCollapse\").set(panel.id, panelSize);\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      expandPanel(params) {\n        const { context, prop, event, refs } = params;\n        const panels = prop(\"panels\");\n        const prevSize = context.get(\"size\");\n        const panel = panels.find((panel2) => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize = 0,\n            minSize: minSizeFromProps = 0,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          const minSize = event.minSize ?? minSizeFromProps;\n          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            const prevPanelSize = refs.get(\"panelSizeBeforeCollapse\").get(panel.id);\n            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      resizePanel(params) {\n        const { context, prop, event } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = getPanelById(panels, event.id);\n        const unsafePanelSize = event.size;\n        const { panelSize, pivotIndices } = panelDataHelper(panels, panel, prevSize);\n        ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"imperative-api\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setPointerValue(params) {\n        const { context, event, prop, scope } = params;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const { resizeTriggerId, initialSize, initialCursorPosition } = dragState;\n        const panels = prop(\"panels\");\n        const panelGroupElement = getRootEl(scope);\n        ensure(panelGroupElement, () => `Panel group element not found`);\n        const pivotIndices = resizeTriggerId.split(\":\").map((id) => panels.findIndex((panel) => panel.id === id));\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const cursorPosition = horizontal ? event.point.x : event.point.y;\n        const groupRect = panelGroupElement.getBoundingClientRect();\n        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;\n        const offsetPixels = cursorPosition - initialCursorPosition;\n        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta: offsetPercentage,\n          initialSize: initialSize ?? prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"mouse-or-touch\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setKeyboardValue(params) {\n        const { context, event, prop } = params;\n        const panelDataArray = prop(\"panels\");\n        const resizeTriggerId = event.id;\n        const delta = event.delta;\n        const pivotIndices = resizeTriggerId.split(\":\").map((id) => panelDataArray.findIndex((panelData) => panelData.id === id));\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels: panelDataArray,\n          pivotIndices,\n          prevSize,\n          trigger: \"keyboard\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      invokeOnResizeEnd({ context, prop }) {\n        queueMicrotask(() => {\n          const dragState = context.get(\"dragState\");\n          prop(\"onResizeEnd\")?.({\n            size: context.get(\"size\"),\n            resizeTriggerId: dragState?.resizeTriggerId ?? null\n          });\n        });\n      },\n      invokeOnResizeStart({ prop }) {\n        queueMicrotask(() => {\n          prop(\"onResizeStart\")?.();\n        });\n      },\n      collapseOrExpandPanel(params) {\n        const { context, prop } = params;\n        const panelDataArray = prop(\"panels\");\n        const sizes = context.get(\"size\");\n        const resizeTriggerId = context.get(\"keyboardState\")?.resizeTriggerId;\n        const [idBefore, idAfter] = resizeTriggerId?.split(\":\") ?? [];\n        const index = panelDataArray.findIndex((panelData2) => panelData2.id === idBefore);\n        if (index === -1) return;\n        const panelData = panelDataArray[index];\n        ensure(panelData, () => `No panel data found for index ${index}`);\n        const size = sizes[index];\n        const { collapsedSize = 0, collapsible, minSize = 0 } = panelData;\n        if (size != null && collapsible) {\n          const pivotIndices = [idBefore, idAfter].map(\n            (id) => panelDataArray.findIndex((panelData2) => panelData2.id === id)\n          );\n          const nextSize = resizeByDelta({\n            delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n            initialSize: context.initial(\"size\"),\n            panels: panelDataArray,\n            pivotIndices,\n            prevSize: sizes,\n            trigger: \"keyboard\"\n          });\n          if (!isEqual(sizes, nextSize)) {\n            setSize(params, nextSize);\n          }\n        }\n      },\n      setGlobalCursor({ context, scope, prop }) {\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const panels = prop(\"panels\");\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const [idBefore] = dragState.resizeTriggerId.split(\":\");\n        const indexBefore = panels.findIndex((panel2) => panel2.id === idBefore);\n        const panel = panels[indexBefore];\n        const size = context.get(\"size\");\n        const aria = getAriaValue(size, panels, dragState.resizeTriggerId);\n        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);\n        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);\n        const cursorState = { isAtMin, isAtMax };\n        setupGlobalCursor(scope, cursorState, horizontal, prop(\"nonce\"));\n      },\n      clearGlobalCursor({ scope }) {\n        removeGlobalCursor(scope);\n      },\n      focusNextResizeTrigger({ event, scope }) {\n        const resizeTriggers = getResizeTriggerEls(scope);\n        const index = resizeTriggers.findIndex((el) => el.dataset.id === event.id);\n        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);\n        handleEl?.focus();\n      }\n    }\n  }\n});\nfunction setSize(params, sizes) {\n  const { refs, prop, context } = params;\n  const panelsArray = prop(\"panels\");\n  const onCollapse = prop(\"onCollapse\");\n  const onExpand = prop(\"onExpand\");\n  const panelIdToLastNotifiedSizeMap = refs.get(\"panelIdToLastNotifiedSizeMap\");\n  context.set(\"size\", sizes);\n  sizes.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    ensure(panelData, () => `Panel data not found for index ${index}`);\n    const { collapsedSize = 0, collapsible, id: panelId } = panelData;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap.set(panelId, size);\n      if (collapsible && (onCollapse || onExpand)) {\n        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size, collapsedSize)) {\n          onExpand?.({ panelId, size });\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size, collapsedSize)) {\n          onCollapse?.({ panelId, size });\n        }\n      }\n    }\n  });\n}\nvar props = createProps()([\n  \"dir\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"onResize\",\n  \"onResizeStart\",\n  \"onResizeEnd\",\n  \"onCollapse\",\n  \"onExpand\",\n  \"orientation\",\n  \"size\",\n  \"defaultSize\",\n  \"panels\",\n  \"keyboardResizeBy\",\n  \"nonce\"\n]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\n\nexport { anatomy, connect, getPanelLayout as layout, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}